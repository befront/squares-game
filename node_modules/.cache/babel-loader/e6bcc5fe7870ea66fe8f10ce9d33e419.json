{"ast":null,"code":"import orderBy from 'lodash/orderBy';\nimport uniq from 'lodash/uniq';\nimport flatten from 'lodash/flatten';\nexport const isCurrentPlayer = (currentPlayer, player) => currentPlayer.id === player.id;\nexport const getCellColor = (rowIndex, columnIndex, players, selectedCells) => {\n  const cell = selectedCells[`${rowIndex}:${columnIndex}`];\n\n  if (!cell) {\n    return '#fff';\n  }\n\n  const player = players[cell.playerId];\n  return player.color;\n};\nexport const getRandomPlayer = players => {\n  const playersKeys = Object.keys(players);\n  const randomKey = playersKeys[Math.floor(Math.random() * playersKeys.length)];\n  return players[randomKey];\n};\nexport const getNextPlayer = (currentPlayer, players) => {\n  const playersKeys = Object.keys(players);\n  const nextPlayerIndex = playersKeys.indexOf(currentPlayer.id) + 1;\n\n  if (nextPlayerIndex > 1) {\n    return players[playersKeys[0]];\n  }\n\n  const nextPlayer = players[playersKeys[nextPlayerIndex]];\n  return nextPlayer;\n};\nexport const isCellIntersect = (prevCell, nextCell) => {\n  return prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex - 1 === nextCell.columnIndex || prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex + 1 === nextCell.columnIndex || prevCell.rowIndex - 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex || prevCell.rowIndex + 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex;\n};\nexport const getIntersectCells = (cells, cell) => {\n  const intersectCells = [];\n\n  for (let i = 0; i < cells.length; i++) {\n    if (isCellIntersect(cells[i], cell)) {\n      intersectCells.push(cells[i]);\n    }\n  }\n\n  return intersectCells;\n};\nexport const getPlayerPoints = cells => {\n  let lines = [];\n  const orderedCells = orderBy(cells, ['rowIndex', 'columnIndex'], 'asc');\n\n  for (let i = 0; i < orderedCells.length; i++) {\n    const cell = `${orderedCells[i].rowIndex}:${orderedCells[i].columnIndex}`;\n    let line = [cell];\n    const intersectCells = getIntersectCells(orderedCells, orderedCells[i]);\n    const linesWithCell = lines.filter(item => item.indexOf(cell) > -1);\n\n    if (linesWithCell.length > 0) {\n      lines.push(uniq(flatten(linesWithCell).concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`))));\n    } else {\n      line = line.concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`));\n      lines.push(line);\n    }\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n  }\n\n  return Math.max.apply(Math, lines.map(line => line.length));\n};\nexport const getWinPlayerName = players => {\n  const playersArr = Object.values(players);\n  const maxPoints = Math.max.apply(Math, playersArr.map(player => player.points));\n  const playersWithMaxPoints = playersArr.filter(player => player.points === maxPoints);\n\n  if (playersWithMaxPoints.length === 2) {\n    return '';\n  }\n\n  return playersWithMaxPoints[0].name;\n};","map":{"version":3,"sources":["/Users/vladislavkorzo/Work/squares-game/src/components/screens/Game/GameScreen.utils.tsx"],"names":["orderBy","uniq","flatten","isCurrentPlayer","currentPlayer","player","id","getCellColor","rowIndex","columnIndex","players","selectedCells","cell","playerId","color","getRandomPlayer","playersKeys","Object","keys","randomKey","Math","floor","random","length","getNextPlayer","nextPlayerIndex","indexOf","nextPlayer","isCellIntersect","prevCell","nextCell","getIntersectCells","cells","intersectCells","i","push","getPlayerPoints","lines","orderedCells","line","linesWithCell","filter","item","concat","map","max","apply","getWinPlayerName","playersArr","values","maxPoints","points","playersWithMaxPoints","name"],"mappings":"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","sourcesContent":["import orderBy from 'lodash/orderBy';\nimport uniq from 'lodash/uniq';\nimport flatten from 'lodash/flatten';\n\nexport const isCurrentPlayer = (currentPlayer: PlayerType, player: PlayerType): boolean => currentPlayer.id === player.id;\n\nexport const getCellColor = (\n    rowIndex: number,\n    columnIndex: number,\n    players: PlayersType,\n    selectedCells: CellsType \n): string => {\n    const cell = selectedCells[`${rowIndex}:${columnIndex}`];\n\n    if (!cell) {\n        return '#fff';\n    }\n\n    const player = players[cell.playerId];\n\n    return player.color;\n};\n\nexport const getRandomPlayer = (players: PlayersType): PlayerType => {\n    const playersKeys = Object.keys(players);\n\n    const randomKey = playersKeys[Math.floor(Math.random() * playersKeys.length)];\n\n    return players[randomKey];\n};\n\nexport const getNextPlayer = (currentPlayer: PlayerType, players: PlayerType): PlayerType => {\n    const playersKeys = Object.keys(players);\n\n    const nextPlayerIndex = playersKeys.indexOf(currentPlayer.id) + 1;\n\n    if (nextPlayerIndex > 1) {\n        return players[playersKeys[0]];\n    }\n\n    const nextPlayer = players[playersKeys[nextPlayerIndex]];\n\n    return nextPlayer;\n};\n\nexport const isCellIntersect = (prevCell: CellType, nextCell: CellType) : boolean => {\n    return (\n        (prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex - 1 === nextCell.columnIndex)\n            || (prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex + 1 === nextCell.columnIndex)\n            || (prevCell.rowIndex - 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex)\n            || (prevCell.rowIndex + 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex)\n    );\n};\n\n\nexport const getIntersectCells = (cells: CellType[], cell: CellType) : CellType[] => {\n    const intersectCells = [];\n\n    for (let i = 0; i < cells.length; i++) {\n        if (isCellIntersect(cells[i], cell)) {\n            intersectCells.push(cells[i]);\n        }\n    }\n\n    return intersectCells;\n};\n\nexport const getPlayerPoints = (cells: CellType[]) : number => {\n    let lines: Array<Array<string>> = [];\n\n    const orderedCells = orderBy(cells, ['rowIndex', 'columnIndex'], 'asc');\n\n    for (let i = 0; i < orderedCells.length; i++) {\n        const cell = `${orderedCells[i].rowIndex}:${orderedCells[i].columnIndex}`;\n\n        let line = [cell];\n            \n        const intersectCells = getIntersectCells(orderedCells, orderedCells[i]);\n\n        const linesWithCell = lines.filter(item => item.indexOf(cell) > -1);\n\n        if (linesWithCell.length > 0) {\n            lines.push(uniq(\n                flatten(linesWithCell)\n                    .concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`))\n                )\n            );\n\n        } else {\n            line = line.concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`));\n\n            lines.push(line);\n        }\n    }\n\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n\n\n    }\n\n    return Math.max.apply(Math, lines.map(line => line.length));\n};\n\nexport const getWinPlayerName = (players: PlayersType) : string => {\n    const playersArr = Object.values(players);\n\n    const maxPoints = Math.max.apply(Math, playersArr.map((player) => player.points));\n\n    const playersWithMaxPoints = playersArr.filter(player => player.points === maxPoints);\n\n    if (playersWithMaxPoints.length === 2) {\n        return '';\n    }\n\n    return playersWithMaxPoints[0].name;\n};"]},"metadata":{},"sourceType":"module"}