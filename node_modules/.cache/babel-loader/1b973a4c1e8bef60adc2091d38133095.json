{"ast":null,"code":"import orderBy from 'lodash/orderBy';\nimport uniq from 'lodash/uniq';\nexport const isCurrentPlayer = (currentPlayer, player) => currentPlayer.id === player.id;\nexport const getCellColor = (rowIndex, columnIndex, players, selectedCells) => {\n  const cell = selectedCells[`${rowIndex}:${columnIndex}`];\n\n  if (!cell) {\n    return '#fff';\n  }\n\n  const player = players[cell.playerId];\n  return player.color;\n};\nexport const getRandomPlayer = players => {\n  const playersKeys = Object.keys(players);\n  const randomKey = playersKeys[Math.floor(Math.random() * playersKeys.length)];\n  return players[randomKey];\n};\nexport const getNextPlayer = (currentPlayer, players) => {\n  const playersKeys = Object.keys(players);\n  const nextPlayerIndex = playersKeys.indexOf(currentPlayer.id) + 1;\n\n  if (nextPlayerIndex > 1) {\n    return players[playersKeys[0]];\n  }\n\n  const nextPlayer = players[playersKeys[nextPlayerIndex]];\n  return nextPlayer;\n}; // export const isCellIntersect = (cells: CellType[], cell: CellType) : boolean => {\n//     for (let i = 0; i < cells.length; i++) {\n//         const currentCell = cells[i];\n//         if ((currentCell.rowIndex === cell.rowIndex && currentCell.columnIndex - 1 === cell.columnIndex)\n//             || (currentCell.rowIndex === cell.rowIndex && currentCell.columnIndex + 1 === cell.columnIndex)\n//             || (currentCell.rowIndex - 1 === cell.rowIndex && currentCell.columnIndex === cell.columnIndex)\n//             || (currentCell.rowIndex + 1 === cell.rowIndex && currentCell.columnIndex === cell.columnIndex)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// };\n\nexport const isCellIntersect = (prevCell, nextCell) => {\n  return prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex - 1 === nextCell.columnIndex || prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex + 1 === nextCell.columnIndex || prevCell.rowIndex - 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex || prevCell.rowIndex + 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex;\n};\nexport const getIntersectCells = (cells, cell) => {\n  const intersectCells = [];\n\n  for (let i = 0; i < cells.length; i++) {\n    if (isCellIntersect(cells[i], cell)) {\n      intersectCells.push(cells[i]);\n    }\n  }\n\n  return intersectCells;\n};\nexport const getPlayerPoints = cells => {\n  let lines = [];\n  debugger;\n  const orderedCells = orderBy(cells, 'rowIndex', 'asc');\n\n  for (let i = 0; i < orderedCells.length; i++) {\n    const cell = `${orderedCells[i].rowIndex}:${orderedCells[i].columnIndex}`;\n    const line = [cell];\n    const intersectCells = getIntersectCells(orderedCells, orderedCells[i]);\n    const lineIndex = lines.findIndex(item => item.indexOf(cell) > -1);\n\n    if (lineIndex > -1) {\n      lines[lineIndex] = uniq(lines[lineIndex].concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`)));\n    } else {\n      line.concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`));\n    }\n\n    lines.push(line);\n  }\n\n  return Math.max.apply(Math, lines.map(line => line.length));\n};\nexport const getWinPlayerName = players => {\n  const playersArr = Object.values(players);\n  const maxPoints = Math.max.apply(Math, playersArr.map(player => player.points));\n  const player = playersArr.find(player => player.points === maxPoints);\n\n  if (!player) {\n    return '';\n  }\n\n  return player.name;\n};","map":{"version":3,"sources":["/Users/vladislavkorzo/Work/squares-game/src/components/screens/Game/GameScreen.utils.tsx"],"names":["orderBy","uniq","isCurrentPlayer","currentPlayer","player","id","getCellColor","rowIndex","columnIndex","players","selectedCells","cell","playerId","color","getRandomPlayer","playersKeys","Object","keys","randomKey","Math","floor","random","length","getNextPlayer","nextPlayerIndex","indexOf","nextPlayer","isCellIntersect","prevCell","nextCell","getIntersectCells","cells","intersectCells","i","push","getPlayerPoints","lines","orderedCells","line","lineIndex","findIndex","item","concat","map","max","apply","getWinPlayerName","playersArr","values","maxPoints","points","find","name"],"mappings":"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","sourcesContent":["import orderBy from 'lodash/orderBy';\nimport uniq from 'lodash/uniq';\n\nexport const isCurrentPlayer = (currentPlayer: PlayerType, player: PlayerType): boolean => currentPlayer.id === player.id;\n\nexport const getCellColor = (\n    rowIndex: number,\n    columnIndex: number,\n    players: PlayersType,\n    selectedCells: CellsType \n): string => {\n    const cell = selectedCells[`${rowIndex}:${columnIndex}`];\n\n    if (!cell) {\n        return '#fff';\n    }\n\n    const player = players[cell.playerId];\n\n    return player.color;\n};\n\nexport const getRandomPlayer = (players: PlayersType): PlayerType => {\n    const playersKeys = Object.keys(players);\n\n    const randomKey = playersKeys[Math.floor(Math.random() * playersKeys.length)];\n\n    return players[randomKey];\n};\n\nexport const getNextPlayer = (currentPlayer: PlayerType, players: PlayerType): PlayerType => {\n    const playersKeys = Object.keys(players);\n\n    const nextPlayerIndex = playersKeys.indexOf(currentPlayer.id) + 1;\n\n    if (nextPlayerIndex > 1) {\n        return players[playersKeys[0]];\n    }\n\n    const nextPlayer = players[playersKeys[nextPlayerIndex]];\n\n    return nextPlayer;\n};\n\n// export const isCellIntersect = (cells: CellType[], cell: CellType) : boolean => {\n//     for (let i = 0; i < cells.length; i++) {\n//         const currentCell = cells[i];\n\n//         if ((currentCell.rowIndex === cell.rowIndex && currentCell.columnIndex - 1 === cell.columnIndex)\n//             || (currentCell.rowIndex === cell.rowIndex && currentCell.columnIndex + 1 === cell.columnIndex)\n//             || (currentCell.rowIndex - 1 === cell.rowIndex && currentCell.columnIndex === cell.columnIndex)\n//             || (currentCell.rowIndex + 1 === cell.rowIndex && currentCell.columnIndex === cell.columnIndex)) {\n//             return true;\n//         }\n//     }\n\n//     return false;\n// };\n\nexport const isCellIntersect = (prevCell: CellType, nextCell: CellType) : boolean => {\n    return (\n        (prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex - 1 === nextCell.columnIndex)\n            || (prevCell.rowIndex === nextCell.rowIndex && prevCell.columnIndex + 1 === nextCell.columnIndex)\n            || (prevCell.rowIndex - 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex)\n            || (prevCell.rowIndex + 1 === nextCell.rowIndex && prevCell.columnIndex === nextCell.columnIndex)\n    );\n};\n\n\nexport const getIntersectCells = (cells: CellType[], cell: CellType) : CellType[] => {\n    const intersectCells = [];\n\n    for (let i = 0; i < cells.length; i++) {\n        if (isCellIntersect(cells[i], cell)) {\n            intersectCells.push(cells[i]);\n        }\n    }\n\n    return intersectCells;\n};\n\nexport const getPlayerPoints = (cells: CellType[]) : number => {\n    let lines: Array<Array<string>> = [];\n\n    debugger;\n\n    const orderedCells = orderBy(cells, 'rowIndex', 'asc');\n\n    for (let i = 0; i < orderedCells.length; i++) {\n        const cell = `${orderedCells[i].rowIndex}:${orderedCells[i].columnIndex}`;\n\n        const line = [cell];\n            \n        const intersectCells = getIntersectCells(orderedCells, orderedCells[i]);\n\n        const lineIndex = lines.findIndex(item => item.indexOf(cell) > -1);\n\n        if (lineIndex > -1) {\n            lines[lineIndex] = uniq(lines[lineIndex]\n                .concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`)));\n        } else {\n            line.concat(intersectCells.map(cell => `${cell.rowIndex}:${cell.columnIndex}`));\n        }\n\n        lines.push(line);\n    }\n\n    return Math.max.apply(Math, lines.map(line => line.length));\n};\n\nexport const getWinPlayerName = (players: PlayersType) : string => {\n    const playersArr = Object.values(players);\n\n    const maxPoints = Math.max.apply(Math, playersArr.map((player) => player.points));\n\n    const player = playersArr.find(player => player.points === maxPoints);\n\n    if (!player) {\n        return '';\n    }\n\n    return player.name;\n};"]},"metadata":{},"sourceType":"module"}